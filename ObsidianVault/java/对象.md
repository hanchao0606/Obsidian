-   创建对象的方式
	- 1、使用new关键字：这是最常用的方式，通过调用类的构造器来创建对象，可以选择有参或 无参的构造器。例如：Person person = new Person(“张三”, 20);
			
	- 2、使用Class类的newInstance方法（9过时了）：这是利用反射机制来创建对象，需要调用类的无参构造器，而且必须是public的。例如：Person person = Person.class.newInstance();
		- (取而代之的方法是使用Class类的getDeclaredConstructor()方法来获取一个Constructor对象，然后调用Constructor类的newInstance()方法来创建对象。这样可以避免上述的问题，并且可以访问任意的构造器，无论是有参还是无参，public还是private。例如： 			Person person = Person.class.getDeclaredConstructor().newInstance(); 			或者 			Person person = Person.class.getDeclaredConstructor(String.class, int.class).newInstance(“张三”, 20);）
	
	- 3、使用Constructor类的newInstance方法：这也是利用反射机制来创建对象，可以调用类的有参或无参的构造器，也可以访问私有的构造器。例如：Constructor<Person> constructor = Person.class.getConstructor(String.class, int.class); Person person = constructor.newInstance(“李四”, 25);
	
	- 4、使用clone方法：这是利用对象的复制来创建对象，需要实现Cloneable接口并重写clone方法，不会调用任何构造器。例如：Person person1 = new Person(“王五”, 30); Person person2 = person1.clone();
		
	- 5、使用反序列化：这是利用对象的序列化和反序列化来创建对象，需要实现Serializable接口，不会调用任何构造器。例如：ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(“person.dat”)); oos.writeObject(new Person(“赵六”, 35)); oos.close(); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(“person.dat”)); Person person = (Person)ois.readObject(); ois.close();
-   对象创建过程
	-   检查类是否已经被加载：当遇到new关键字时，JVM会检查运行时常量池中是否有该类的符号引用，如果没有，就会进行类的加载过程，包括加载、验证、准备、解析和初始化五个阶段。
	-  为对象分配内存空间：当类被加载后，JVM会在堆内存中为对象分配一定大小的空间，这个大小在类加载完成时就已经确定。分配内存空间有两种方式：指针碰撞和本地线程分配缓冲（TLAB）。指针碰撞是将堆区划分为已使用和未使用两部分，通过移动指针来分配空间，适用于内存地址连续的情况。TLAB是为每个线程预先分配一块小内存，在这块内存中分配空间，避免了多线程竞争的问题。
	-   为对象字段设置零值：当内存空间分配好后，JVM会对对象的字段进行零值初始化，即将所有字段赋值为0或null。这样做是为了保证对象的安全性，避免出现未定义的值。
	-   设置对象头：对象头是对象的元数据信息，包括对象的哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等。对象头也包括类型指针，指向该对象所属类的元数据信息。
	-   执行构造方法：最后一步是执行对象的构造方法，这是程序员真正想要做的操作，例如初始化其他字段、调用其他方法等。构造方法可以有参或无参，public或private。执行完构造方法后，对象创建完成。

-   字节码层面创建过程
	-   执行new指令：这个指令会接收一个常量池的索引，指向一个类或者接口的符号引用。JVM会检查这个符号引用是否已经被解析和初始化，如果没有，就会进行类的加载、验证、准备、解析和初始化的过程。然后，JVM会在堆内存中为对象分配空间，并将对象的字段初始化为零值。最后，JVM会将对象的引用压入操作数栈中。
	-   执行dup指令：这个指令会复制操作数栈顶的值，并将副本压入操作数栈中。这样做是为了保留对象的引用，因为下一步执行构造方法时会消耗掉栈顶的值。
	-   执行invokespecial指令：这个指令会调用对象的构造方法，也就是<init>方法。这个方法可以有参数或者无参数，public或者private。执行完构造方法后，对象创建完成。

-   对象实例化过程
	- 类初始化检查：JVM会检查要创建对象的类是否已经被加载、解析和初始化过，如果没有，就会先执行类的加载和初始化过程。
	- 分配内存：JVM会在堆内存中为对象分配一块合适的空间，这个空间的大小由对象的属性、状态和对齐方式决定。分配内存的方式有指针碰撞和空闲列表两种，具体取决于堆内存是否规整。同时，为了避免多线程并发分配内存时出现冲突，JVM可以采用CAS配上失败重试或者TLAB方式来保证线程安全。
	- 初始化零值：JVM会将分配好的内存空间初始化为零值，也就是将对象的所有属性设置为对应数据类型的默认值，比如int类型的0，引用类型的null等。
	- 设置对象头：JVM会在对象的内存空间中设置对象头，包括对象的哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等信息。同时，还会设置一个指向类元数据的指针，用于确定对象是哪个类的实例。
	- 执行构造方法：JVM会执行对象的构造方法，也就是<init>方法，这个方法由非静态变量赋值代码、非静态代码块和对应的构造器组成。执行<init>方法时，会先调用父类的<init>方法，然后按照代码顺序给非静态变量赋值，并执行非静态代码块和构造器。执行完<init>方法后，对象创建完成。

-   加载类信息
	-   加载：通过类的全限定名找到对应的.class文件，并将其字节码读入内存，转换成方法区的运行时数据结构，同时在堆中创建一个java.lang.Class对象。
	-   验证：检查字节码是否符合Java虚拟机规范，是否有安全问题，是否符合Java语言规范等。
	-   准备：为类的静态变量分配内存，并设置默认初始值。
	-   解析：将常量池中的符号引用转换为直接引用，即确定类或接口、字段、方法等的实际内存地址。
	-   初始化：执行类构造器<clinit>()方法，给静态变量赋予程序员定义的值，执行静态代码块等。

	-加载类信息的时机有以下几种情况：

	-   使用new关键字实例化对象时
	-   读取或设置一个类的静态字段或调用一个类的静态方法时
	-   使用反射方式操作类时
	-   初始化一个类的子类时
	-   Java虚拟机启动时加载主类



-   对象内存分配
	-  对象的大小由其实例变量的类型和数量决定，不同的对象可能占用不同大小的内存空间。
	-   对象内存分配可以采用两种方式：指针碰撞和空闲列表。指针碰撞是在堆中维护一个指针，指向下一个可用的内存地址，当需要分配内存时，只需将指针向上移动相应的大小即可。空闲列表是在堆中维护一个列表，记录哪些内存块是空闲的，当需要分配内存时，从列表中找到一个足够大的空闲块，并将其标记为已用。
	-   对象内存分配可能会受到线程竞争的影响，为了提高效率和安全性，每个线程可以在堆中预先分配一小块内存，称为TLAB（Thread Local Allocation Buffer），这样线程在分配对象时，只需在自己的TLAB中进行操作，无需加锁或同步。
	-   对象内存分配可能会受到垃圾回收器的影响，不同的垃圾回收器可能会采用不同的算法和策略来管理堆中的空间，例如分代收集、标记清除、标记整理、复制等。
	
-  对象头信息是指在Java堆中存储对象时，除了对象的实例数据之外，还需要存储一些额外的信息，用于支持一些特殊的功能，例如垃圾回收、同步、哈希码等。对象头信息一般由以下三部分组成
	-   Mark Word：一个64位的标记字，用于存储对象的哈希码、分代年龄、锁状态、偏向线程ID、偏向时间戳等信息。Mark Word的内容和格式会随着对象的状态变化而变化，例如无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态等。
	-   Klass Pointer：一个指针，指向对象所属类的元数据信息，用于确定对象是哪个类的实例。Klass Pointer一般占32位或64位，取决于是否开启了指针压缩功能。
	-   Array Length：一个整数，只有当对象是数组时才存在，用于记录数组的长度。Array Length占32位


-   对象内存布局是指Java对象在堆内存中的组成结构，一般由以下三部分组成：
	-   对象头（Object header）：包括了关于堆对象的布局、类型、GC状态、同步状态和标识哈希码的基本信息。对象头一般由两个字（64位）组成，分别是Mark Word和Klass Pointer。如果对象是数组，还需要额外记录数组长度。
	-   实例数据（Instance data）：存放对象的真正有效数据，即各个属性字段的值。实例数据的大小和顺序取决于字段的类型和虚拟机的分配策略。
	-   对齐填充（Padding）：为了满足虚拟机要求的8字节对齐，如果对象头和实例数据不足8字节的整数倍，就需要用对齐填充来补齐。对齐填充不是必须存在的部分，只有在需要时才会有。
	-要查看对象内存布局，可以使用openjdk提供的JOL工具，它可以打印出对象的内存信息，包括偏移地址、大小、类型、描述和值等。

-   对象访问方式:对象访问方式是指Java虚拟机如何通过栈上的reference类型数据来定位和访问堆上的具体对象。Java虚拟机规范并没有规定对象访问方式，不同的虚拟机实现可能有不同的方式。目前主流的对象访问方式有两种：
	- 通过句柄访问：这种方式下，Java堆中会划分出一块内存作为句柄池，reference中存储的是对象的句柄地址，句柄中包含了对象实例数据和类型数据的具体地址信息。这种方式的优势是对象移动时只需改变句柄中的实例数据指针，而不用修改reference。
	- 通过直接指针访问：这种方式下，Java堆中的对象布局必须包含类型数据的相关信息，reference中存储的是对象的直接地址。这种方式的优势是速度快，节省了一次指针定位的开销，因为对象访问在Java中非常频繁。